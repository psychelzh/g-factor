---
title: "Prepare figures and tables for the manuscript"
author: "Liang Zhang"
---

```{r}
#| label: setup

devtools::load_all()
library(modelsummary)
library(patchwork)

path_ms <- normalizePath(
  fs::path(
    Sys.getenv("OneDriveConsumer"),
    "Documents/Research/brain-intelligence/g-factor/manuscripts"
  )
)
path_ms_fig <- fs::path(path_ms, "figures")
path_ms_tbl <- fs::path(path_ms, "tables")

config_task_index <- read_csv("tasks_index.csv", show_col_types = FALSE)
task_name_abbr <- config_task_index |>
  select(abbr_name, task_index) |>
  deframe()
match_abbr <- function(tasks) {
  names(task_name_abbr)[match(tasks, task_name_abbr)]
}

# helper functions
arrange_plots <- function(plot_fun, adj_mat_pool, ...) {
  add_custom_title <- function(text, where = c("row", "column")) {
    where <- match.arg(where)
    if (where == "row") {
      side <- 2
      at <- grconvertY(0.5, "npc", "nic")
    } else {
      side <- 3
      at <- grconvertX(0.5, "npc", "nic")
    }
    mtext(text, side = side, line = 0, at = at, outer = TRUE)
  }
  par(oma = c(0, 2, 2, 0), mfrow = c(2, 3), mar = c(0, 0, 0, 0) + 0.1)
  for (idx_row in 1:2) {
    for (idx_col in 1:3) {
      cur_adj_mat <- adj_mat_pool |>
        filter(row == idx_row, col == idx_col)
      plot_fun(
        cur_adj_mat$adj_mat[[1]], ...,
        model_type = cur_adj_mat$model_type
      )
      # add column and row annotations
      text_model_type <- model_types[[cur_adj_mat$model_type]]
      text_meas_trait <- meas_trait[[cur_adj_mat$trait]]
      if (idx_row == 1) {
        add_custom_title(text_meas_trait, "column")
        if (idx_col == 1) {
          add_custom_title(text_model_type, "row")
        }
      } else {
        if (idx_col == 1) {
          add_custom_title(text_model_type, "row")
        }
      }
    }
  }
}
average_correlation <- function(x) tanh(mean(atanh(x)))
```

```{r}
#| label: descriptive-statistics

targets::tar_load(
  c(subjs_info_clean, indices_wider_clean, indices_clean),
  store = store_preproc_behav
)
subjs_combined <- scan(here::here(file_subjs_combined))

descr_behav <- subjs_info_clean |>
  semi_join(indices_wider_clean, by = "sub_id") |>
  select(sub_id, age, sex) |>
  report::report_participants()
descr_fmri <- subjs_info_clean |>
  filter(sub_id %in% subjs_combined) |>
  select(sub_id, age, sex) |>
  report::report_participants()

indices <- config_task_index |>
  left_join(
    indices_clean |>
      semi_join(indices_wider_clean, by = "sub_id") |>
      mutate(n_indices = n_distinct(index), .by = disp_name) |>
      mutate(
        task_index = if_else(
          n_indices == 2,
          str_c(disp_name, ".", index),
          disp_name
        )
      ),
    by = "task_index"
  ) |>
  mutate(
    task_index = as_factor(task_index),
    abbr_name = as_factor(abbr_name)
  )
indices |>
  reframe(
    psych::describe(score),
    .by = c(disp_name, index, dim)
  ) |>
  select(
    dim, disp_name, index,
    n, mean, sd, min, max,
    skew, kurtosis
  ) |>
  mutate(across(where(is.numeric), ~ round(., 2))) |>
  writexl::write_xlsx(fs::path(path_ms_tbl, "stats_desc.xlsx"))
p_hist <- indices |>
  ggplot(aes(score)) +
  geom_histogram() +
  facet_wrap(~ abbr_name, scales = "free_x", ncol = 4) +
  ggpubr::theme_pubr() +
  labs(x = "Score", y = "Count")
ggsave(fs::path(path_ms_fig, "hist_all_tasks.png"), p_hist, width = 12, height = 10)
```

```{r}
#| label: cfa-statistics

tar_load(data_subsamples, store = store_preproc_behav)
tar_load(fit_spearman, store = store_preproc_behav)
tar_load(fit_bifac, store = store_preproc_behav)

p_miss <- indices_wider_clean |>
  select(all_of(task_name_abbr)) |>
  naniar::vis_miss() +
  theme(axis.text.x = element_text(angle = 90))
ggsave(fs::path(path_ms_fig, "missing_pattern.png"), p_miss, width = 8, height = 6)

p_corrmat <- indices_wider_clean |>
  select(all_of(task_name_abbr)) |>
  ggstatsplot::ggcorrmat(
    cor.vars = all_of(config_task_index$abbr_name),
    colors = c("#084594", "white", "#99000D"),
    pch = "",
    ggcorrplot.args = list(pch.cex = 2, lab_size = 2)
  ) +
  scale_x_discrete(position = "top") +
  theme(axis.text.x.top = element_text(hjust = 0), aspect.ratio = 1)
ggsave(fs::path(path_ms_fig, "cfa_task_corrs.pdf"), p_corrmat, width = 10, height = 8)

vss_stats <- data_subsamples[[1]] |>
  select(-sub_id) |>
  psych::vss(n = 10, plot = FALSE)
p_nfact <- vss_stats$vss.stats |>
  as_tibble(rownames = "n_fact") |>
  mutate(n_fact = as.integer(n_fact)) |>
  ggplot(aes(n_fact, eBIC)) +
  geom_point() +
  geom_line() +
  scale_x_continuous(
    name = "Number of factors",
    breaks = scales::breaks_width(2)
  ) +
  scale_y_continuous(
    name = "Empirical BIC"
  ) +
  ggpubr::theme_pubr()
ggsave(fs::path(path_ms_fig, "cfa_nfact.pdf"), p_nfact, width = 6, height = 8)

p_cfa_prep <- p_corrmat + p_nfact +
  plot_annotation(tag_levels = "A")
ggsave(fs::path(path_ms_fig, "cfa_prep.png"), p_cfa_prep, width = 12, height = 6)

cairo_pdf(
  filename = fs::path(path_ms_fig, "cfa_struct_spearman.pdf"),
  width = 8, height = 16
)
semPlot::semPaths(
  fit_spearman$nf1,
  whatLabels = "std",
  rotation = 2,
  layout = "tree2",
  nodeLabels = c(match_abbr(rownames(loadings(fit_spearman))), "GCA-S"),
  intercepts = FALSE,
  nCharNodes = 0,
  sizeMan = 5,
  sizeMan2 = 3.5,
  edge.label.cex = 0.5,
  residuals = TRUE
)
dev.off()

group_struct <- parameterTable(fit_bifac) |> filter(op == "=~", lhs != "g")
cairo_pdf(
  filename = fs::path(path_ms_fig, "cfa_struct_bifac.pdf"),
  width = 8, height = 16
)
semPlot::semPaths(
  fit_bifac,
  whatLabels = "std",
  layout = "tree2",
  rotation = 2,
  nodeLabels = c(
    match_abbr(group_struct$rhs),
    "GCA-B",
    unique(group_struct$lhs)
  ),
  intercepts = FALSE,
  bifactor = "g",
  nCharNodes = 0,
  sizeMan = 5,
  sizeMan2 = 3.5,
  edge.label.cex = 0.5,
  exoCov = FALSE,
  residuals = TRUE
)
dev.off()

bind_rows(
  spearman = tar_read(fit_meas_spearman, store = store_preproc_behav),
  bifactor = tar_read(fit_meas_bifac, store = store_preproc_behav),
  .id = "model"
) |>
  select(model, df = df, RMSEA = rmsea, SRMR = srmr, CFI = cfi, TLI = tli) |>
  writexl::write_xlsx(fs::path(path_ms_tbl, "fit_meas.xlsx"))
```

```{r}
#| label: influence-on-reliabilty-validity

# composite reliability
p_comp_rel <- tar_read(comp_rel, store = store_gca_numtasks) |>
  ggplot(aes(num_vars, prop, group = factor(num_vars))) +
  # geom_violin() +
  geom_boxplot() +
  geomtextpath::geom_texthline(
    yintercept = tar_read(comp_rel_spearman, store = store_preproc_behav),
    linetype = "dotted",
    hjust = 0,
    color = "black",
    label = "All"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(3)) +
  ggpubr::theme_pubr() +
  labs(x = "Number of Tasks", y = "Variance Explained")
ggsave(fs::path(path_ms_fig, "com_rel.png"), p_comp_rel, width = 8, height = 6)

datasummary(
  Factor(num_vars) ~ prop * (Mean + SD + Min + Max),
  tar_read(comp_rel, store = store_gca_numtasks),
  fmt = 3,
  output = fs::path(path_ms_tbl, "com_rel.xlsx")
)

# visualize pairwise correlation and correlation with RAPM
rel_pairs <- tar_read(scores_g, store = store_gca_numtasks) |>
  group_by(num_vars, idx_rsmp) |>
  filter(n() == 2) |>
  summarise(
    r = cor(scores[[1]]$g, scores[[2]]$g, use = "pairwise"),
    .groups = "drop"
  )
datasummary(
  Factor(num_vars) ~ r * (Median + SD + Min + Max),
  rel_pairs,
  fmt = 3,
  output = fs::path(path_ms_tbl, "rel_pairs.xlsx")
)
cor_rapm_gca <- bind_rows(
  spearman = tar_read(scores_spearman, store = store_preproc_behav),
  bifac = tar_read(scores_bifac, store = store_preproc_behav),
  .id = "trait"
) |>
  inner_join(
    tar_read(scores_rapm, store = store_preproc_behav),
    by = "sub_id"
  ) |>
  summarise(
    r = cor(g, RAPM, use = "pairwise"),
    r_fisher = atanh(r),
    .by = trait
  )
cor_rapm_sampled <- tar_read(scores_g, store = store_gca_numtasks) |>
  unnest(scores) |>
  inner_join(
    tar_read(scores_rapm, store = store_preproc_behav),
    by = "sub_id"
  ) |>
  summarise(
    r = cor(g, RAPM, use = "pairwise"),
    r_fisher = atanh(r),
    .by = c(num_vars, id_pairs, idx_rsmp)
  )
datasummary(
  Factor(num_vars) ~ r * (Median + SD + Min + Max),
  cor_rapm_sampled,
  fmt = 3,
  output = fs::path(path_ms_tbl, "cor_rapm_sampled.xlsx")
)

fit_rel <- nls(
  r ~ eta1 * (1 - exp(-eta2 * num_vars)),
  data = rel_pairs,
  start = list(eta1 = 1, eta2 = 0.01),
  lower = c(eta1 = 0, eta2 = 0),
  algorithm = "port"
)
pred_range_rel <- seq(3, 40)
predicted_rel <- tibble(
  num_vars = pred_range_rel,
  r = predict(fit_rel, list(num_vars = pred_range_rel))
)
p_rel <- rel_pairs |>
  ggplot(aes(num_vars, r)) +
  ggdist::stat_slabinterval() +
  ggdist::stat_dots(side = "left") +
  geom_point(
    data = predicted_rel,
    mapping = aes(num_vars, r),
    size = 1,
    color = "#FFD966"
  ) +
  geom_line(
    data = predicted_rel,
    mapping = aes(num_vars, r),
    linetype = "dotted",
    color = "#FFD966"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(2)) +
  ggpubr::theme_pubclean() +
  labs(x = "Number of Tasks", y = "Correlation Between Pairs")

fit_rapm <- nls(
  r ~ eta1 * (1 - exp(-eta2 * num_vars)),
  data = cor_rapm_sampled,
  start = list(eta1 = 1, eta2 = 0.01),
  lower = c(eta1 = 0, eta2 = 0),
  algorithm = "port"
)
pred_range_rapm <- seq(3, 40)
predicted_rapm <- tibble(
  num_vars = pred_range_rapm,
  r = predict(fit_rapm, list(num_vars = pred_range_rapm))
)
p_cor_ramp <- cor_rapm_sampled |>
  ggplot(aes(num_vars, r)) +
  ggdist::stat_slabinterval() +
  ggdist::stat_dots(side = "left") +
  geomtextpath::geom_texthline(
    aes(
      yintercept = r,
      # https://github.com/AllanCameron/geomtextpath/issues/75
      label = gsub("-", "\u2212", meas_trait[trait], fixed = T),
      color = trait
    ),
    cor_rapm_gca,
    hjust = 0,
    linetype = "dashed",
    show.legend = FALSE
  ) +
  geom_point(
    data = predicted_rapm,
    mapping = aes(num_vars, r),
    size = 1,
    color = "#FFD966"
  ) +
  geom_line(
    data = predicted_rapm,
    mapping = aes(num_vars, r),
    linetype = "dotted",
    color = "#FFD966"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(2)) +
  scale_color_manual(values = color_traits) +
  ggpubr::theme_pubclean() +
  labs(x = "Number of Tasks", y = "Correlation with RAPM")

p <- p_rel / p_cor_ramp +
  plot_annotation(tag_levels = "A")
ggsave(fs::path(path_ms_fig, "task_influence_behav_only.png"), p, width = 10, height = 6)
```

```{r}
#| label: benchmark-cpm

# prepare data ----
cpm_pred <- targets::tar_read(
  cpm_pred,
  store = store_cpm_bench
) |>
  mutate(
    type = if_else(
      str_detect(cond, "eq"),
      "Equal Duration",
      "Origin Duration"
    ),
    cond = str_remove(cond, "eq")
  ) |>
  filter(cond != "run1rest")
pred_hypers <- cpm_pred |>
  filter(
    type == "Equal Duration",
    cond == "nbackrun1",
    gsr == "with"
  ) |>
  mutate(
    cond = factor(cond, names(conds)),
    parcel = factor(parcel, names(parcels)),
    gsr = factor(gsr, names(gsrs))
  )
pred_cond <- cpm_pred |>
  filter(
    thresh_method == "alpha",
    thresh_level == 0.01
  ) |>
  mutate(
    cond = factor(cond, names(conds)),
    parcel = factor(parcel, names(parcels)),
    gsr = factor(gsr, names(gsrs))
  )

# plot in main text ----
p_hypers <- pred_hypers |>
  filter(parcel == "nn268") |>
  ggplot(aes(factor(thresh_level), all)) +
  geom_boxplot(width = 0.4) +
  scale_x_discrete(name = "Threshold Level") +
  scale_y_continuous(
    name = "CPM Performance",
    breaks = scales::breaks_width(0.02)
  ) +
  facet_grid(
    cols = vars(thresh_method),
    labeller = labeller(
      thresh_method = thresh_methods
    ),
    scales = "free_x"
  ) +
  ggpubr::theme_pubr()
p_cond <- pred_cond |>
  filter(parcel == "nn268", type == "Equal Duration") |>
  ggplot(aes(cond, all)) +
  geom_boxplot(width = 0.4) +
  rlang::exec(scale_x_discrete, !!!scale_conds) +
  scale_y_continuous(
    name = "CPM Performance",
    breaks = scales::breaks_width(0.03)
  ) +
  facet_grid(
    cols = vars(gsr),
    labeller = labeller(gsr = gsrs)
  ) +
  ggpubr::theme_pubr()
p <- p_hypers / p_cond +
  plot_layout(heights = c(1, 2)) +
  plot_annotation(tag_levels = "A") &
  theme(legend.position = "bottom")
ggsave(fs::path(path_ms_fig, "bench_cpm.png"), p, width = 8, height = 6)

# plot in supplementary ----
p_hypers_parcel <- pred_hypers |>
  ggplot(aes(factor(thresh_level), all, fill = parcel)) +
  geom_boxplot() +
  scale_x_discrete(name = "Threshold Level") +
  rlang::exec(ggthemes::scale_fill_few, !!!scale_parcels) +
  scale_y_continuous(
    name = "CPM Performance",
    breaks = scales::breaks_width(0.02)
  ) +
  facet_grid(
    cols = vars(thresh_method),
    labeller = labeller(
      thresh_method = thresh_methods
    ),
    scales = "free_x"
  ) +
  ggpubr::theme_pubr()
p_cond_parcel <- pred_cond |>
  filter(type == "Equal Duration") |>
  ggplot(aes(cond, all, fill = parcel)) +
  geom_boxplot() +
  rlang::exec(scale_x_discrete, !!!scale_conds) +
  scale_y_continuous(name = "CPM Performance") +
  rlang::exec(ggthemes::scale_fill_few, !!!scale_parcels) +
  facet_grid(
    cols = vars(gsr),
    labeller = labeller(gsr = gsrs)
  ) +
  ggpubr::theme_pubr()
p_parcel <- p_hypers_parcel / p_cond_parcel +
  plot_layout(heights = c(1, 2), guides = "collect") +
  plot_annotation(tag_levels = "A") &
  theme(legend.position = "bottom")
ggsave(fs::path(path_ms_fig, "bench_cpm_with_parcels.png"), p_parcel, width = 8, height = 6)

# extra check ----
p_duration <- pred_cond |>
  ggplot(aes(cond, all, fill = type)) +
  geom_boxplot() +
  rlang::exec(scale_x_discrete, !!!scale_conds) +
  scale_y_continuous(name = "CPM Performance") +
  rlang::exec(ggthemes::scale_fill_few, name = "") +
  facet_grid(
    cols = vars(gsr),
    rows = vars(parcel),
    labeller = labeller(gsr = gsrs, parcel = parcels)
  ) +
  ggpubr::theme_pubr()
ggsave(fs::path(path_ms_fig, "bench_cpm_duration.png"), p_duration, width = 8, height = 6)
```

```{r}
#| label: neural-prediction

preds_main <- targets::tar_read(
  cpm_pred,
  store = store_cpm_main
) |>
  filter(
    cond == "nbackrun1",
    parcel == "nn268",
    gsr == "with",
    trait %in% names(meas_trait),
    thresh_method == "alpha",
    thresh_level == 0.01
  ) |>
  summarise(
    estimate = average_correlation(all),
    .by = any_of(
      c("trait", names(config), names(hypers_cpm))
    )
  )
preds_sampled <- targets::tar_read(
  cpm_pred,
  store = store_gca_numtasks
) |>
  filter(gsr == "with", parcel == "nn268") |>
  summarise(
    estimate = average_correlation(all),
    .by = c(
      num_vars, id_pairs, idx_rsmp,
      any_of(c(names(config), names(hypers_cpm)))
    )
  )

p_pred_trend <- preds_sampled |>
  ggplot(aes(num_vars, estimate)) +
  ggdist::stat_slabinterval() +
  ggdist::stat_dots(side = "left") +
  geomtextpath::geom_texthline(
    aes(
      color = trait,
      yintercept = estimate,
      label = gsub("-", "\u2212", meas_trait[trait], fixed = T)
    ),
    preds_main,
    hjust = 0,
    linetype = "dashed",
    show.legend = FALSE
  ) +
  scale_x_continuous(breaks = scales::breaks_width(2)) +
  scale_color_manual(values = color_traits) +
  ggpubr::theme_pubr() +
  theme(legend.position = c(0.8, 0.2)) +
  labs(x = "Number of Tasks", y = "CPM Performance")

dice_clean <- targets::tar_read(
  dice_mask_pairs,
  store = store_gca_numtasks
) |>
  mutate(dice_avg = (pos_dice + neg_dice) / 2) |>
  filter(
    parcel == "nn268",
    binarize_method == "prob",
    binarize_level == 0.95,
    cond == "nbackrun1"
  )
p_dice_avg <- dice_clean |>
  ggplot(aes(num_vars, dice_avg)) +
  ggdist::stat_slabinterval() +
  ggdist::stat_dots(side = "left") +
  scale_x_continuous(breaks = scales::breaks_width(2)) +
  ggpubr::theme_pubr() +
  labs(x = "Number of Tasks", y = "Dice Similarity")

p <- p_pred_trend + p_dice_avg +
  plot_layout(widths = c(2, 1)) +
  plot_annotation(tag_levels = "A")
ggsave(fs::path(path_ms_fig, "pred_cpm_dice_avg.png"), p, width = 8, height = 4)

datasummary(
  Factor(num_vars) ~ estimate * (Median + SD + Max + Min),
  preds_sampled,
  fs::path(path_ms_tbl, "preds_sampled_cpm.xlsx")
)
datasummary(
  Factor(num_vars) ~
    dice_avg * (Median + SD + Max + Min),
  dice_clean,
  fs::path(path_ms_tbl, "dice_clean.xlsx")
)

# supplementary
dice_clean_supp <- targets::tar_read(
  dice_mask_pairs,
  store = store_gca_numtasks
) |>
  pivot_longer(
    contains("dice"),
    names_to = c("model_type", ".value"),
    names_pattern = "(.+)_(.+)"
  ) |>
  filter(
    binarize_method == "prob",
    binarize_level != 0.9,
    cond == "nbackrun1"
  ) |>
  mutate(
    parcel = factor(parcel, names(parcels)),
    model_type = factor(model_type, names(model_types)) |>
      droplevels()
  )

p_dice_supp <- dice_clean_supp |>
  ggplot(aes(num_vars, dice)) +
  ggdist::stat_slabinterval(aes(fill = model_type), show.legend = FALSE) +
  ggdist::stat_dots(side = "left", show.legend = FALSE) +
  scale_x_continuous(breaks = scales::breaks_width(2)) +
  ggpubr::theme_pubr() +
  ggh4x::facet_nested(
    rows = vars(model_type),
    cols = vars(parcel, binarize_level),
    labeller = labeller(
      model_type = model_types,
      parcel = parcels
    )
  ) +
  labs(x = "Number of Tasks", y = "Dice Similarity")
ggsave(fs::path(path_ms_fig, "dice_supp.png"), p_dice_supp, width = 8, height = 6)
```

```{r}
#| label: benchmark-single-task
#| eval: false

bench_single <- bind_rows(
  `Single Task` = targets::tar_read(
    cpm_pred_single,
    store = store_cpm_tasksel
  ),
  `Intelligence` = targets::tar_read(
    cpm_pred,
    store = store_cpm_main
  ) |>
    filter(
      cond == "nbackrun1",
      parcel == "nn268",
      gsr == "with",
      thresh_method == "alpha",
      thresh_level == 0.01
    ) |>
    mutate(task = meas_trait[idx]),
  .id = "type"
) |>
  mutate(
    type = factor(type, c("Intelligence", "Single Task")),
    cond = factor(cond, names(conds)),
    gsr = factor(gsr, names(gsrs))
  )
p <- bench_single |>
  ggplot(aes(fct_reorder(task, desc(all)), all)) +
  geom_boxplot() +
  facet_grid(cols = vars(type), space = "free", scales = "free_x") +
  ggpubr::theme_pubr() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Task Indicator", y = "CPM Performance")
ggsave(fs::path(path_ms_fig, "bench_single.png"), p, width = 8, height = 6)
```

```{r}
#| label: single-task-loading-gca

tar_load(loadings_mdl, store = store_cpm_tasksel)
tar_load(cor_task_gca, store = store_cpm_tasksel)
loading_corrs <- cor_task_gca |> 
  left_join(
    as_tibble(unclass(loadings_mdl), rownames = "target"), 
    by = "target"
  )
p <- loading_corrs |> 
  ggplot(aes(f1, r)) +
  geom_point() +
  ggpubr::theme_pubr() +
  labs(x = "Loading on GCA", y = "Correlation with GCA")
ggsave(fs::path(path_ms_fig, "scatter-loading-cor_gca.png"), p, width = 8, height = 6)
writexl::write_xlsx(
  loading_corrs, 
  fs::path(path_ms_tbl, "loading-cor_gca.xlsx")
)
```

```{r}
#| label: prepare-brain-mask-data

# ROI preparation
roi_info <- prepare_roi_info(readRDS(here::here("data/atlases/Shen268.rds")))
roi_coords <- as.matrix(select(roi_info, contains("mni")))
# writexl::write_xlsx(count(roi_info, label), fs::path(path_ms_tbl, "roi_counts.xlsx"))

# load brain masks of interest
brain_masks <- targets::tar_read(
  brain_mask,
  store = store_cpm_main
) |>
  filter(
    trait %in% names(meas_trait),
    cond == "nbackrun1", gsr == "with", acq == "reg",
    thresh_method == "alpha", thresh_level == 0.01,
    parcel == "nn268"
  )

# prepare adjacency matrices
adj_mat_pool <- brain_masks |>
  pivot_longer(
    any_of(names(model_types)),
    names_to = "model_type",
    values_to = "mask"
  ) |>
  mutate(
    adj_mat = map(
      mask,
      ~ prepare_adjacency(
        .x,
        binarize_method = "prob",
        binarize_level = 0.95,
        diagonal = 0
      )
    ),
    node_degree = map(
      adj_mat,
      ~ igraph::graph_from_adjacency_matrix(
        .x,
        mode = "undirected"
      ) |>
        igraph::degree()
    ),
    .keep = "unused"
  ) |>
  mutate(
    trait = factor(trait, names(meas_trait)),
    model_type = factor(model_type, names(model_types)),
    row = as.integer(droplevels(model_type)),
    col = as.integer(trait)
  )
```

```{r}
#| label: stats-cor-brain-mask

dice_simil <- brain_masks |>
  pivot_longer(
    cols = any_of(names(model_types)),
    names_to = "model_type",
    values_to = "mask"
  ) |>
  pivot_wider(
    names_from = trait,
    values_from = mask
  ) |>
  rowwise() |>
  mutate(
    dplyover::across2x(
      all_of(names(meas_trait)),
      all_of(names(meas_trait)),
      list(
        dice = ~ list(.x[[1]], .y[[1]]) |>
          calc_mask_dice(
            binarize_method = "prob",
            binarize_level = 0.95
          )
      ),
      .comb = "minimal"
    )
  ) |>
  ungroup() |>
  select(model_type, contains("dice")) |>
  pivot_longer(
    contains("dice"),
    names_to = c("trait_x", "trait_y", ".value"),
    names_pattern = "(.*)_(.*)_(.*)"
  )
rho_node_degree <- adj_mat_pool |>
  select(trait, model_type, node_degree) |>
  pivot_wider(
    names_from = trait,
    values_from = node_degree
  ) |>
  rowwise() |>
  mutate(
    dplyover::across2x(
      all_of(names(meas_trait)),
      all_of(names(meas_trait)),
      list(rho = ~ cor(.x[[1]], .y[[1]], method = "spearman")),
      .comb = "minimal"
    )
  ) |>
  ungroup() |>
  select(model_type, contains("rho")) |>
  pivot_longer(
    contains("rho"),
    names_to = c("trait_x", "trait_y", ".value"),
    names_pattern = "(.*)_(.*)_(.*)"
  )

plots <- dice_simil |>
  inner_join(rho_node_degree, by = join_by(model_type, trait_x, trait_y)) |>
  pivot_longer(
    c(dice, rho),
    names_to = "meas_cor",
    values_to = "val"
  ) |>
  nest(.by = c(meas_cor, model_type)) |>
  arrange(meas_cor) |>
  pmap(
    \(model_type, meas_cor, data) {
      meas <- c(rho = "Edge counts correlation", dice = "Edge dice similarity")
      data |>
        ggplot(aes(trait_x, trait_y, fill = val)) +
        geom_raster() +
        scale_x_discrete(labels = meas_trait, name = NULL, position = "top") +
        scale_y_discrete(labels = meas_trait, name = NULL, position = "right") +
        scale_fill_distiller(
          name = NULL,
          breaks = scales::breaks_width(0.1),
          direction = 1,
          palette = if (model_type == "pos") "Reds" else "Blues"
        ) +
        ggtitle(meas[meas_cor], subtitle = model_types[model_type]) +
        coord_flip() +
        theme_minimal() +
        theme(
          panel.grid = element_blank(),
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          axis.text.y = element_text(angle = 90),
          aspect.ratio = 1
        )
    }
  )
p <- wrap_plots(plots, nrow = 1)
ggsave(fs::path(path_ms_fig, "network-similarity.pdf"), width = 12, height = 3)
```

```{python}
#| label: plot-markers

import os
import numpy as np
import pandas as pd
from nilearn import plotting
import matplotlib.pyplot as plt

fig = plt.figure()
gs = fig.add_gridspec(nrows=2, ncols=3, wspace=0.1, hspace=0)
axes = gs.subplots()

# Compute node degree values (dummy values for demonstration)
for row in range(2):
  for col in range(3):
    ax = axes[row, col]
    cur_adj_mat = r.adj_mat_pool.query('row == @row + 1 & col == @col + 1').to_dict(orient='records')[0]
    model_type = cur_adj_mat['model_type']
    node_degree = cur_adj_mat['node_degree']
    if model_type == "pos":
      cmap = plt.cm.Reds
    else:
      cmap = plt.cm.Blues
    plotting.plot_markers(
      node_degree,
      r.roi_coords,
      node_cmap=cmap,
      colorbar=True,
      axes=ax
    )

# set column and row titles
title_rows = r.model_types[1:]
title_cols = r.meas_trait
pad = 10
for ax, title_col in zip(axes[0], title_cols):
  ax.set_title(title_col)

for i, ax, title_row in zip(range(2), axes[:,0], title_rows):
  ax.annotate(
    title_row,
    xy=(0, 0.5),
    xytext=(-ax.yaxis.labelpad - pad, 0),
    textcoords='offset points',
    size='large', rotation=90,
    ha='center', va='center'
  )

fig.set_size_inches(20, 6)
fig.savefig(
  os.path.join(r.path_ms_fig, "network-nodes-wide.pdf"),
  dpi=100, bbox_inches='tight'
)
fig.clear()
```

```{r}
#| label: plot-chord-ctb

cairo_pdf(fs::path(path_ms_fig, "network-chord.pdf"), width = 8, height = 12)
arrange_plots(
  visualize_chord,
  adj_mat_pool,
  roi_info = roi_info,
  link_val = "enrich",
  add_legend = TRUE
)
dev.off()

cairo_pdf(fs::path(path_ms_fig, "network-chord-nohemi.pdf"), width = 8, height = 12)
arrange_plots(
  visualize_chord,
  adj_mat_pool,
  roi_info = roi_info,
  link_val = "enrich",
  add_legend = TRUE,
  group_by_hemi = FALSE
)
dev.off()
```

```{r}
#| label: plot-enrichment

cairo_pdf(fs::path(path_ms_fig, "network-corrplot-wide.pdf"), width = 12, height = 8)
arrange_plots(
  visualize_corrplot,
  adj_mat_pool,
  labels = roi_info$label,
  which = "enrich"
)
dev.off()
```

```{r}
#| label: stats-enrichment

adj_mat_pool |>
  reframe(
    map(
      adj_mat,
      ~ summarise_adjacency(.x, roi_info$label)
    ) |>
      list_rbind(),
    .by = c(trait, model_type)
  ) |>
  slice_max(enrich, n = 2, by = c(trait, model_type))
```

```{r}
#| label: top-nodes

nodes_degree_sorted <- adj_mat_pool |>
  select(trait, model_type, node_degree) |>
  mutate(
    node_degree = map(
      node_degree,
      ~ tibble(
        index = seq_along(.x),
        degree = .x
      )
    )
  ) |>
  unnest(node_degree) |>
  mutate(
    rank = min_rank(desc(degree)),
    .by = c(trait, model_type)
  )

nodes_degree_sorted |>
  expand_grid(
    n_top = seq(10, 100, by = 10)
  ) |>
  mutate(top = rank <= n_top) |>
  nest(.by = c(trait, model_type, n_top)) |>
  pivot_wider(
    names_from = trait,
    values_from = data
  ) |>
  pivot_longer(
    c(spearman, bifac),
    names_to = "gca",
    values_to = "nodes"
  ) |>
  mutate(
    n = map2_dbl(
      rapm, nodes,
      ~ sum(colSums(rbind(.x$top, .y$top)) == 2)
    ),
    prop = n / n_top
  )

nodes_degree_sorted |>
  filter(rank <= 10) |>
  left_join(roi_info, by = "index") |>
  mutate(
    pmap(
      list(x.mni, y.mni, z.mni),
      \(x.mni, y.mni, z.mni) {
        label4MRI::mni_to_region_name(x.mni, y.mni, z.mni) |>
          as_tibble()
      }
    ) |>
      list_rbind()
  ) |>
  mutate(
    rank = min_rank(desc(degree)),
    .by = c(trait, model_type)
  ) |>
  arrange(model_type, trait, rank) |>
  select(trait, model_type, rank, ends_with("mni"), ends_with("label")) |>
  mutate(
    trait = meas_trait[as.character(trait)],
    model_type = model_types[as.character(model_type)],
    ba.label = as.integer(str_extract(ba.label, "\\d+"))
  ) |>
  writexl::write_xlsx(fs::path(path_ms_tbl, "top_nodes.xlsx"))
```
